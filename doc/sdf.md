# MSDF/SDF Text Rendering in RustPixel

## Background

RustPixel uses a single texture atlas for all rendering. In the 8192x8192 atlas, four regions coexist:

| Region | Linear Index | Cell Size | Count | Rendering |
|--------|-------------|-----------|-------|-----------|
| Sprite | 0 - 40959 | 16x16 | 40960 | Bitmap |
| TUI | 40960 - 43519 | 32x64 | 2560 | **MSDF** |
| Emoji | 43520 - 44287 | 64x64 | 768 | Bitmap |
| CJK | 44288 - 48383 | 64x64 | 4096 | **SDF** |

TUI characters (box-drawing, ASCII, Nerd Font symbols) use true MSDF generated by `msdfgen`, while CJK characters use bitmap-to-SDF (distance field derived from PingFang SC bitmap rendering via `scipy.ndimage.distance_transform_edt`). Sprite and Emoji remain pure bitmap.

## What is MSDF?

**Multi-channel Signed Distance Field (MSDF)** encodes the distance to the nearest glyph edge into the RGB channels of a texture. Each channel carries an independent distance value, enabling the reconstruction of sharp corners that single-channel SDF cannot preserve.

At render time, a fragment shader computes:

```wgsl
fn median3(r: f32, g: f32, b: f32) -> f32 {
    return max(min(r, g), min(max(r, g), b));
}

let d = median3(texColor.r, texColor.g, texColor.b);
let w = max(fwidth(d), 0.03);
let alpha = smoothstep(0.5 - w, 0.5 + w, d);
```

The `median3` of the three channels produces a single distance value. `smoothstep` with a screen-space derivative (`fwidth`) creates anti-aliased edges that remain crisp at any zoom level.

### MSDF vs Bitmap

| | Bitmap | SDF | MSDF |
|---|--------|-----|------|
| Sharp corners | N/A | Rounded | Preserved |
| Zoom quality | Blurs | Crisp but rounded corners | Crisp with sharp corners |
| Color channels | RGBA = actual color | R=G=B=distance | R,G,B = independent distances |
| Best for | Sprites, Emoji | CJK (acceptable) | TUI glyphs |

## MDPT Fullscreen Requirements

MDPT (Markdown Presentation Tool) is the primary consumer of this feature. As a fullscreen presentation tool, MDPT faces a unique scaling challenge:

1. **No letterboxing** -- `is_letterboxing_enabled()` returns `false`, so the content stretches to fill the entire window/screen.
2. **Fullscreen mode** -- When launched with `-f`, the window fills the entire display at native resolution (e.g. 2560x1600, 3840x2160).
3. **Large magnification** -- A TUI cell originally designed at 32x64 pixels in the atlas may be displayed at 4-8x magnification on a 4K screen.

With bitmap textures, this magnification causes visible blur and pixelation on text and box-drawing characters. MSDF/SDF rendering solves this: the distance field produces mathematically smooth edges regardless of scale.

## Engine Implementation

### Per-Instance MSDF Flag (Zero Overhead)

The MSDF flag is encoded in the sign bit of `origin_y` in per-instance data:

```rust
// render_symbols.rs
let origin_y = if use_msdf { -frame.origin_y } else { frame.origin_y };
```

The vertex shader extracts the flag and passes `abs(origin_y)` as the actual origin:

```wgsl
output.v_msdf = select(0.0, 1.0, instance.a1.y < 0.0);
let origin = abs(instance.a1.xy);
```

This costs zero extra memory per instance.

### Fragment Shader Dual Path

The fragment shader branches on `v_msdf`:

- **MSDF/SDF path**: Color comes from the instance's foreground color (`input.colorj.rgb`), alpha from the distance field. RGB channels in the texture are distance data, not color.
- **Bitmap path**: `texColor * input.colorj` -- texture color multiplied by instance color. Sprites have their own palette colors; Emoji have embedded color.

### Bold Support

Both paths handle bold:

- **MSDF bold**: Lowers the threshold from 0.5 to 0.45, expanding the glyph outline.
- **Bitmap bold**: Samples neighboring texels to thicken strokes.

### Auto-Detection and API

MSDF mode is auto-detected from texture size:

```rust
// In load_texture():
self.msdf_enabled = texw >= 8192;
```

- **8192x8192 textures**: MSDF/SDF enabled (new format)
- **4096x4096 textures**: Pure bitmap (legacy format)

Users can override this via the public API:

```rust
// Enable MSDF rendering
context.adapter.set_msdf_enabled(true);

// Disable MSDF (force bitmap mode for all symbols)
context.adapter.set_msdf_enabled(false);
```

## Texture Generation

The `tools/symbols/generate_symbols.py` script generates the 8192x8192 atlas:

```bash
cd tools/symbols
python3 generate_symbols.py --size 8192 --msdf
```

### TUI: True MSDF via msdfgen

For TUI characters (ASCII, box-drawing, Nerd Font icons), the script calls `msdfgen`:

```bash
msdfgen msdf -font DroidSansMNerdFont-Regular.ttf <codepoint> \
    -size 32 64 -pxrange 4 -emnormalize -o output.png
```

The `-emnormalize` flag ensures consistent glyph sizing across all characters. If `msdfgen` fails for a particular glyph (missing in font), the script falls back to bitmap-to-SDF.

### CJK: PingFang SC Bitmap-to-SDF

CJK characters use macOS PingFang SC rendered via Core Text (Quartz), then converted to SDF using `scipy.ndimage.distance_transform_edt`. This approach was chosen because:

1. PingFang SC produces the best visual quality for CJK at these sizes.
2. Apple's PingFang.ttc does not expose glyph outline data, so `msdfgen` cannot process it.
3. Bitmap-to-SDF still provides significantly better scaling than raw bitmap.

### Sprite & Emoji: Unchanged

Sprite blocks are loaded from C64 character ROM PNG. Emoji use Apple Color Emoji bitmap rendering. Both remain pure bitmap -- no distance field conversion.

## File Overview

| File | Role |
|------|------|
| `tools/symbols/generate_symbols.py` | Atlas generation (MSDF + SDF + bitmap) |
| `src/render/adapter/wgpu/render_symbols.rs` | Instance data generation, MSDF flag encoding |
| `src/render/adapter/wgpu/shader_source.rs` | WGSL vertex/fragment shaders with MSDF path |
| `src/render/adapter.rs` | `set_msdf_enabled()` trait API |
| `src/render/symbol_map.rs` | Layout constants (`TUI_BASE`, `CJK_BASE`, etc.) |
