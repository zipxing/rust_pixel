# ç»ˆç«¯æ¨¡æ‹Ÿå™¨çš„å­—ç¬¦æ¸²æŸ“ç­–ç•¥ç ”ç©¶

## ä¸»æµç»ˆç«¯æ¨¡æ‹Ÿå™¨å¦‚ä½•å¤„ç†ä¸åŒç±»å‹å­—ç¬¦

### 1. æ ¸å¿ƒæ¸²æŸ“ç­–ç•¥ï¼šåŠ¨æ€å­—ä½“æ¸²æŸ“

**æ‰€æœ‰ç°ä»£ç»ˆç«¯æ¨¡æ‹Ÿå™¨éƒ½ä½¿ç”¨å­—ä½“æ¸²æŸ“å¼•æ“**ï¼Œè€Œä¸æ˜¯é¢„åˆ¶çš„ç¬¦å·çº¹ç†å›¾é›†ã€‚

```
ç»ˆç«¯æ¨¡æ‹Ÿå™¨çš„æ¸²æŸ“ç®¡çº¿ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å­—ç¬¦ä¸²è¾“å…¥                                      â”‚
â”‚  "Hello â”‚â”€â” ğŸ­"                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å­—ä½“æ¸²æŸ“å¼•æ“ (FreeType/CoreText/DirectWrite)   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  1. Unicode åˆ†æ (wcwidth, å­—ç¬¦å±æ€§)     â”‚   â”‚
â”‚  â”‚  2. å­—å½¢æŸ¥æ‰¾ (Glyph lookup)              â”‚   â”‚
â”‚  â”‚  3. å­—ä½“å›é€€ (Font fallback)             â”‚   â”‚
â”‚  â”‚  4. å…‰æ …åŒ– (Rasterization)               â”‚   â”‚
â”‚  â”‚  5. çº¹ç†ç¼“å­˜ (Glyph cache)               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GPU æ¸²æŸ“ (OpenGL/Metal/DirectX)                â”‚
â”‚  - å°†å­—å½¢çº¹ç†è´´åˆ° quad ä¸Š                       â”‚
â”‚  - å¤„ç†é¢œè‰²ã€æ ·å¼ï¼ˆbold, italic, underlineï¼‰   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. å…·ä½“ç»ˆç«¯å®ç°åˆ†æ

#### Alacritty (Rust, é«˜æ€§èƒ½)
**GitHub**: https://github.com/alacritty/alacritty

**æ¸²æŸ“ç­–ç•¥**ï¼š
```rust
// ä½¿ç”¨ fontdue æˆ– freetype-rs è¿›è¡Œå­—ä½“æ¸²æŸ“
// src/renderer/text.rs (ä¼ªä»£ç ç¤ºæ„)

fn render_cell(cell: &Cell, x: f32, y: f32) {
    let glyph_key = GlyphKey::new(cell.c, cell.flags);
    
    // ä»ç¼“å­˜è·å–æˆ–æ¸²æŸ“å­—å½¢
    let glyph = glyph_cache.get_or_insert(glyph_key, || {
        font_rasterizer.rasterize(cell.c, font_size)
    });
    
    // æ¸²æŸ“åˆ° GPU
    renderer.draw_glyph(x, y, glyph, cell.fg, cell.bg);
}
```

**å­—ç¬¦å¤„ç†**ï¼š
- **æ–‡æœ¬å­—ç¬¦**: ä½¿ç”¨ä¸»å­—ä½“ï¼ˆMonospace fontï¼‰
- **å›¾å½¢ç¬¦å·**: åŒæ ·ä½¿ç”¨å­—ä½“æ¸²æŸ“ï¼Œéƒ¨åˆ†ç»ˆç«¯æœ‰ç‰¹æ®Šçš„"box drawing"ä¼˜åŒ–
- **Emoji**: é€šè¿‡å­—ä½“å›é€€æœºåˆ¶ï¼ˆfont fallbackï¼‰è‡ªåŠ¨ä½¿ç”¨ç³»ç»Ÿ Emoji å­—ä½“

**å…³é”®æŠ€æœ¯**ï¼š
- âœ… **å­—å½¢ç¼“å­˜ (Glyph Cache)**ï¼šå·²æ¸²æŸ“çš„å­—ç¬¦å­˜å‚¨åœ¨çº¹ç†å›¾é›†ä¸­ï¼Œé¿å…é‡å¤å…‰æ …åŒ–
- âœ… **å­—ä½“å›é€€ (Font Fallback)**ï¼šä¸»å­—ä½“æ‰¾ä¸åˆ°å­—ç¬¦æ—¶ï¼Œè‡ªåŠ¨å°è¯•å¤‡ç”¨å­—ä½“
- âœ… **GPU åŠ é€Ÿ**ï¼šä½¿ç”¨ OpenGL å®ä¾‹åŒ–æ¸²æŸ“ï¼ˆinstanced renderingï¼‰

#### WezTerm (Rust, åŠŸèƒ½ä¸°å¯Œ)
**GitHub**: https://github.com/wez/wezterm

**ç‰¹è‰²**ï¼š
```rust
// WezTerm ä½¿ç”¨ harfbuzz-rs è¿›è¡Œæ–‡æœ¬æ•´å½¢ï¼ˆtext shapingï¼‰
// æ”¯æŒå¤æ‚æ–‡å­—ï¼ˆé˜¿æ‹‰ä¼¯æ–‡ã€å°åœ°è¯­ç­‰ï¼‰

// å­—ç¬¦å®½åº¦å¤„ç†
fn cell_width(c: char) -> usize {
    match unicode_width::UnicodeWidthChar::width(c) {
        Some(2) => 2,  // åŒå®½å­—ç¬¦ï¼ˆCJK, Emojiï¼‰
        Some(0) => 0,  // ç»„åˆå­—ç¬¦
        _ => 1,        // æ™®é€šå­—ç¬¦
    }
}
```

**Emoji å¤„ç†**ï¼š
- macOS: ä½¿ç”¨ CoreText è‡ªåŠ¨åŠ è½½ `Apple Color Emoji` å­—ä½“
- Linux: ä½¿ç”¨ fontconfig åŠ è½½ `Noto Color Emoji`
- Windows: ä½¿ç”¨ DirectWrite åŠ è½½ `Segoe UI Emoji`

#### Kitty (C/Python, å…ˆè¿›ç‰¹æ€§)
**GitHub**: https://github.com/kovidgoyal/kitty

**åˆ›æ–°ç‚¹**ï¼š
1. **è‡ªå®šä¹‰æ¡†çº¿æ¸²æŸ“**ï¼šä¸ä¾èµ–å­—ä½“ï¼Œç›´æ¥ç”¨ OpenGL ç»˜åˆ¶å®Œç¾çš„æ¡†çº¿
```c
// æ¡†çº¿å­—ç¬¦ (U+2500-U+257F) ä½¿ç”¨å‡ ä½•å›¾å½¢ç»˜åˆ¶
if (is_box_drawing_char(c)) {
    draw_box_drawing_line(c, x, y, cell_width, cell_height);
} else {
    draw_font_glyph(c, x, y);
}
```

2. **å›¾åƒåè®®**ï¼šæ”¯æŒåœ¨ç»ˆç«¯ä¸­æ˜¾ç¤ºçœŸå®çš„å›¾ç‰‡ï¼ˆä¸åªæ˜¯ Emojiï¼‰
3. **GPU åŠ é€Ÿ**ï¼šæ‰€æœ‰æ¸²æŸ“éƒ½åœ¨ GPU ä¸Šå®Œæˆ

### 3. å­—ç¬¦ç±»å‹çš„ç»Ÿä¸€å¤„ç†æ–¹æ¡ˆ

#### æ–¹æ¡ˆï¼šå­—ä½“æ¸²æŸ“ + å­—å½¢ç¼“å­˜

```rust
// ç»Ÿä¸€çš„å­—ç¬¦æ¸²æŸ“æ¥å£
pub trait CharRenderer {
    fn render_char(&mut self, c: char, style: Style) -> GlyphTexture;
}

// å®ç°
pub struct FontRenderer {
    primary_font: Font,           // ä¸»å­—ä½“ï¼ˆMonospaceï¼‰
    fallback_fonts: Vec<Font>,    // å¤‡ç”¨å­—ä½“
    glyph_cache: HashMap<GlyphKey, CachedGlyph>,
}

impl FontRenderer {
    fn render_char(&mut self, c: char, style: Style) -> GlyphTexture {
        let key = GlyphKey { c, style };
        
        // 1. æ£€æŸ¥ç¼“å­˜
        if let Some(cached) = self.glyph_cache.get(&key) {
            return cached.texture;
        }
        
        // 2. å°è¯•ä¸»å­—ä½“
        if let Some(glyph) = self.primary_font.rasterize(c) {
            return self.cache_and_return(key, glyph);
        }
        
        // 3. å­—ä½“å›é€€
        for font in &self.fallback_fonts {
            if let Some(glyph) = font.rasterize(c) {
                return self.cache_and_return(key, glyph);
            }
        }
        
        // 4. æ˜¾ç¤º tofu (è±†è…å— â–¡)
        return self.missing_glyph();
    }
}
```

#### å­—ç¬¦å®½åº¦å¤„ç†ï¼ˆå…³é”®ï¼ï¼‰

```rust
use unicode_width::UnicodeWidthChar;

fn get_cell_width(c: char) -> usize {
    match c.width() {
        Some(0) => 0,  // ç»„åˆå­—ç¬¦ã€é›¶å®½å­—ç¬¦
        Some(2) => 2,  // åŒå®½å­—ç¬¦ï¼ˆCJKã€Emojiï¼‰
        _ => 1,        // å•å®½å­—ç¬¦
    }
}

// æ¸²æŸ“æ—¶çš„å¤„ç†
fn render_line(cells: &[Cell]) {
    let mut x = 0.0;
    let mut skip_next = false;
    
    for cell in cells {
        if skip_next {
            skip_next = false;
            continue;
        }
        
        let width = get_cell_width(cell.char);
        render_glyph(cell.char, x, y, width * CELL_WIDTH, CELL_HEIGHT);
        
        if width == 2 {
            skip_next = true;  // Emoji å 2æ ¼ï¼Œè·³è¿‡ä¸‹ä¸€ä¸ª Cell
        }
        x += CELL_WIDTH;
    }
}
```

### 4. æ¡†çº¿å­—ç¬¦çš„ç‰¹æ®Šä¼˜åŒ–

#### ç­–ç•¥ Aï¼šå­—ä½“æ¸²æŸ“ï¼ˆç®€å•ä½†å¯èƒ½ä¸å®Œç¾ï¼‰
å¤§å¤šæ•°ç»ˆç«¯ç›´æ¥ä½¿ç”¨å­—ä½“ä¸­çš„æ¡†çº¿å­—ç¬¦ï¼Œä½†å¯èƒ½ä¼šæœ‰ï¼š
- çº¿æ¡ç²—ç»†ä¸ä¸€è‡´
- è¿æ¥å¤„æœ‰ç¼éš™
- ä¸åŒå­—ä½“æ•ˆæœå·®å¼‚å¤§

#### ç­–ç•¥ Bï¼šå‡ ä½•ç»˜åˆ¶ï¼ˆKitty çš„æ–¹æ³•ï¼Œå®Œç¾ä½†å¤æ‚ï¼‰
```rust
fn draw_box_drawing(c: char, x: f32, y: f32, w: f32, h: f32) {
    match c {
        'â”€' => draw_line(x, y + h/2, x + w, y + h/2),      // æ°´å¹³çº¿
        'â”‚' => draw_line(x + w/2, y, x + w/2, y + h),      // å‚ç›´çº¿
        'â”Œ' => {
            draw_line(x + w/2, y + h/2, x + w, y + h/2);   // å³
            draw_line(x + w/2, y + h/2, x + w/2, y + h);   // ä¸‹
        },
        'â”' => {
            draw_line(x, y + h/2, x + w/2, y + h/2);       // å·¦
            draw_line(x + w/2, y + h/2, x + w/2, y + h);   // ä¸‹
        },
        // ... å…¶ä»–æ¡†çº¿å­—ç¬¦
    }
}
```

### 5. Emoji çš„å¤„ç†ï¼ˆæœ€å¤æ‚ï¼‰

#### å½©è‰² Emoji çš„ä¸‰ç§æ ¼å¼

1. **CBDT/CBLC (Apple Color Emoji)**
   - ä½å›¾æ ¼å¼ï¼ŒåŒ…å«é¢„æ¸²æŸ“çš„ PNG å›¾åƒ
   - å›ºå®šå°ºå¯¸ï¼ˆå¦‚ 160x160ï¼‰

2. **COLR/CPAL (Google Noto Color Emoji)**
   - çŸ¢é‡æ ¼å¼ï¼Œä½¿ç”¨å¤šä¸ªå›¾å±‚
   - å¯ç¼©æ”¾

3. **SVG (æŸäº›å­—ä½“)**
   - SVG æ ¼å¼çš„ Emoji
   - æœ€çµæ´»ä½†æ¸²æŸ“å¤æ‚

#### å­—ä½“æ¸²æŸ“åº“çš„æ”¯æŒ

```rust
// ä½¿ç”¨ freetype-rs åŠ è½½å½©è‰² Emoji
use freetype as ft;

fn load_emoji(face: &ft::Face, c: char) -> Option<RgbaImage> {
    let glyph_index = face.get_char_index(c as usize);
    
    // åŠ è½½å½©è‰²å­—å½¢
    face.load_glyph(glyph_index, ft::face::LoadFlag::COLOR)?;
    
    // è·å– RGBA ä½å›¾
    let bitmap = face.glyph().bitmap();
    if bitmap.pixel_mode() == ft::bitmap::PixelMode::Bgra {
        // å·²ç»æ˜¯å½©è‰²ï¼Œç›´æ¥ä½¿ç”¨
        return Some(convert_to_rgba(bitmap));
    }
    
    None
}
```

### 6. æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

#### å­—å½¢ç¼“å­˜ï¼ˆGlyph Cacheï¼‰
```rust
pub struct GlyphCache {
    // çº¹ç†å›¾é›†ï¼ˆTexture Atlasï¼‰
    atlas: TextureAtlas,
    
    // å­—å½¢ç´¢å¼•
    cache: HashMap<GlyphKey, AtlasEntry>,
    
    // LRU æ·˜æ±°ç­–ç•¥
    lru: LruCache<GlyphKey>,
}

impl GlyphCache {
    fn get_or_render(&mut self, key: GlyphKey) -> &AtlasEntry {
        if !self.cache.contains_key(&key) {
            // æ¸²æŸ“å­—å½¢
            let glyph = self.font.rasterize(key.char);
            
            // åˆ†é…çº¹ç†ç©ºé—´
            let entry = self.atlas.allocate(glyph.width, glyph.height);
            
            // ä¸Šä¼ åˆ° GPU
            self.atlas.upload(entry.x, entry.y, &glyph.data);
            
            // ç¼“å­˜
            self.cache.insert(key, entry);
            self.lru.put(key);
        }
        
        self.cache.get(&key).unwrap()
    }
}
```

#### å®ä¾‹åŒ–æ¸²æŸ“ï¼ˆInstanced Renderingï¼‰
```glsl
// é¡¶ç‚¹ç€è‰²å™¨
layout(location = 0) in vec2 vertex_pos;      // Quad é¡¶ç‚¹
layout(location = 1) in vec2 cell_pos;        // æ¯ä¸ªå­—ç¬¦çš„å±å¹•ä½ç½®
layout(location = 2) in vec4 tex_coords;      // çº¹ç†åæ ‡
layout(location = 3) in vec4 fg_color;        // å‰æ™¯è‰²
layout(location = 4) in vec4 bg_color;        // èƒŒæ™¯è‰²

void main() {
    vec2 pos = vertex_pos * cell_size + cell_pos;
    gl_Position = projection * vec4(pos, 0.0, 1.0);
    // ...
}
```

ä¸€æ¬¡ `glDrawArraysInstanced` è°ƒç”¨æ¸²æŸ“æ•´ä¸ªå±å¹•çš„æ‰€æœ‰å­—ç¬¦ã€‚

## æ€»ç»“ï¼šç»ˆç«¯æ¨¡æ‹Ÿå™¨çš„ç»éªŒå¯¹ rust_pixel çš„å¯ç¤º

### æ ¸å¿ƒç»éªŒ
1. **ä¸è¦é¢„åˆ¶ç¬¦å·çº¹ç†** - ä½¿ç”¨åŠ¨æ€å­—ä½“æ¸²æŸ“æ›´çµæ´»
2. **å­—å½¢ç¼“å­˜æ˜¯å…³é”®** - é¿å…é‡å¤å…‰æ …åŒ–
3. **å­—ä½“å›é€€æœºåˆ¶** - è‡ªåŠ¨æ”¯æŒå„ç§å­—ç¬¦ï¼ˆåŒ…æ‹¬ Emojiï¼‰
4. **Unicode å®½åº¦æ„ŸçŸ¥** - æ­£ç¡®å¤„ç†åŒå®½å­—ç¬¦

### åº”ç”¨åˆ° rust_pixel çš„å»ºè®®

#### çŸ­æœŸæ–¹æ¡ˆï¼ˆä¿æŒå½“å‰æ¶æ„ï¼‰
```
rust_pixel å½“å‰ï¼šé¢„åˆ¶ç¬¦å·çº¹ç†ï¼ˆsymbols.pngï¼‰
â”œâ”€ ä¼˜ç‚¹ï¼šæ€§èƒ½å¥½ï¼ŒåŠ è½½å¿«
â”œâ”€ ç¼ºç‚¹ï¼šç¬¦å·æ•°é‡æœ‰é™ï¼Œä¸æ”¯æŒ Emoji
â””â”€ é€‚ç”¨ï¼šæ¸¸æˆåœºæ™¯ï¼Œå›ºå®šçš„ç¬¦å·é›†

å»ºè®®ï¼š
- Phase 1: ä½¿ç”¨ç»Ÿä¸€çº¹ç†ï¼ˆTUI + Sprite åŒºåŸŸï¼‰
- æš‚ä¸æ”¯æŒ Emojiï¼ˆæ–‡æœ¬æ¨¡å¼ä¾ç„¶å¯ç”¨ï¼‰
- å›¾å½¢ç¬¦å·æ‹‰ä¼¸æš‚æ—¶æ¥å—
```

#### é•¿æœŸæ–¹æ¡ˆï¼ˆå­¦ä¹ ç»ˆç«¯æ¨¡æ‹Ÿå™¨ï¼‰
```
rust_pixel æœªæ¥ï¼šæ··åˆæ¸²æŸ“æ¶æ„
â”œâ”€ é¢„åˆ¶çº¹ç†ï¼šæ¸¸æˆç²¾çµã€å›ºå®šç¬¦å·
â”œâ”€ å­—ä½“æ¸²æŸ“ï¼šTUI æ–‡æœ¬ã€Emoji
â””â”€ å­—å½¢ç¼“å­˜ï¼šåŠ¨æ€ç”Ÿæˆçš„å­—ç¬¦

å®ç°æ­¥éª¤ï¼š
1. é›†æˆ fontdue æˆ– rusttype
2. å®ç°å­—å½¢ç¼“å­˜ç³»ç»Ÿ
3. åœ¨ Cell ä¸­æ ‡è®°æ¸²æŸ“ç±»å‹ï¼ˆçº¹ç† vs å­—ä½“ï¼‰
4. æ¸²æŸ“æ—¶åˆ†åˆ«å¤„ç†
```

### å…·ä½“æŠ€æœ¯é€‰å‹

#### å­—ä½“æ¸²æŸ“åº“ï¼ˆRustï¼‰
1. **fontdue** â­ æ¨è
   - çº¯ Rust å®ç°
   - æ€§èƒ½å¥½
   - ç®€å•æ˜“ç”¨
   - ä¸æ”¯æŒå½©è‰² Emojiï¼ˆéœ€è¦å•ç‹¬å¤„ç†ï¼‰

2. **rusttype**
   - çº¯ Rust å®ç°
   - æˆç†Ÿç¨³å®š
   - ä¸æ”¯æŒå½©è‰² Emoji

3. **freetype-rs**
   - FreeType çš„ Rust ç»‘å®š
   - åŠŸèƒ½æœ€å®Œæ•´
   - æ”¯æŒå½©è‰² Emoji (CBDT/COLR)
   - éœ€è¦ç³»ç»Ÿä¾èµ–

#### æ¨èæ¶æ„ï¼ˆæ¸è¿›å¼ï¼‰

```rust
// æ··åˆæ¸²æŸ“æ¶æ„
pub enum CellContent {
    // é¢„åˆ¶çº¹ç†ï¼ˆå½“å‰æ–¹å¼ï¼‰
    PrerenderedSymbol { 
        texsym: usize,  // çº¹ç†ç´¢å¼•
        fg: Color,
        bg: Color,
    },
    
    // åŠ¨æ€å­—ä½“æ¸²æŸ“ï¼ˆæ–°å¢ï¼‰
    DynamicChar {
        c: char,
        font_id: u8,    // å­—ä½“ ID
        fg: Color,
        bg: Color,
    },
    
    // Emojiï¼ˆæœªæ¥ï¼‰
    Emoji {
        c: char,
        // ä½¿ç”¨å½©è‰²çº¹ç†ç¼“å­˜
    },
}

impl CellRenderer {
    fn render(&mut self, cell: &Cell) {
        match &cell.content {
            CellContent::PrerenderedSymbol { texsym, fg, bg } => {
                // å½“å‰æ–¹å¼ï¼šä» symbols.png æ¸²æŸ“
                self.render_from_texture(*texsym, *fg, *bg);
            },
            CellContent::DynamicChar { c, font_id, fg, bg } => {
                // æ–°æ–¹å¼ï¼šä»å­—ä½“æ¸²æŸ“
                let glyph = self.glyph_cache.get_or_render(*c, *font_id);
                self.render_glyph(glyph, *fg, *bg);
            },
            CellContent::Emoji { c } => {
                // æœªæ¥ï¼šå½©è‰² Emoji
                let texture = self.emoji_cache.get_or_render(*c);
                self.render_emoji_texture(texture);
            },
        }
    }
}
```

### æœ€ä½³å®è·µæ€»ç»“

| ç‰¹æ€§ | ç»ˆç«¯æ¨¡æ‹Ÿå™¨ | rust_pixel å½“å‰ | rust_pixel å»ºè®® |
|------|-----------|----------------|----------------|
| **æ–‡æœ¬å­—ç¬¦** | å­—ä½“æ¸²æŸ“ | é¢„åˆ¶çº¹ç† | Phase 2: å­—ä½“æ¸²æŸ“ |
| **å›¾å½¢ç¬¦å·** | å­—ä½“æˆ–å‡ ä½• | é¢„åˆ¶çº¹ç† | Phase 1: é¢„åˆ¶çº¹ç† |
| **Emoji** | å­—ä½“å›é€€ | âŒ ä¸æ”¯æŒ | Phase 3: å­—ä½“æ¸²æŸ“ |
| **å­—å½¢ç¼“å­˜** | âœ… åŠ¨æ€ç¼“å­˜ | âœ… é™æ€çº¹ç† | Phase 2: æ··åˆ |
| **åŒå®½å­—ç¬¦** | âœ… wcwidth | âœ… å·²æ”¯æŒ | âœ… ä¿æŒ |
| **æ€§èƒ½** | é«˜ï¼ˆç¼“å­˜ï¼‰ | é«˜ï¼ˆé¢„åˆ¶ï¼‰ | é«˜ï¼ˆæ··åˆï¼‰ |

## ç»“è®º

**ç»ˆç«¯æ¨¡æ‹Ÿå™¨çš„æ ¸å¿ƒç­–ç•¥æ˜¯"åŠ¨æ€å­—ä½“æ¸²æŸ“ + å­—å½¢ç¼“å­˜"**ï¼Œè¿™è®©å®ƒä»¬èƒ½å¤Ÿï¼š
- âœ… æ”¯æŒä»»æ„ Unicode å­—ç¬¦
- âœ… è‡ªåŠ¨å¤„ç† Emojiï¼ˆé€šè¿‡å­—ä½“å›é€€ï¼‰
- âœ… é«˜æ€§èƒ½ï¼ˆå­—å½¢ç¼“å­˜ï¼‰
- âœ… çµæ´»ï¼ˆç”¨æˆ·å¯æ¢å­—ä½“ï¼‰

**rust_pixel çš„æœ€ä½³è·¯å¾„**ï¼š
1. **Phase 1**: ä¿æŒé¢„åˆ¶çº¹ç†ï¼Œå¿«é€Ÿå®ç° TUI åŸºç¡€æ¶æ„
2. **Phase 2**: å¼•å…¥å­—ä½“æ¸²æŸ“ï¼Œä¸“é—¨å¤„ç† TUI æ–‡æœ¬
3. **Phase 3**: å®Œæ•´æ”¯æŒ Emojiï¼ˆå­¦ä¹ ç»ˆç«¯æ¨¡æ‹Ÿå™¨ï¼‰

è¿™æ ·æ—¢ä¿ç•™äº†æ¸¸æˆåœºæ™¯çš„é«˜æ€§èƒ½ï¼ˆé¢„åˆ¶çº¹ç†ï¼‰ï¼Œåˆè·å¾—äº† TUI åœºæ™¯çš„çµæ´»æ€§ï¼ˆå­—ä½“æ¸²æŸ“ï¼‰ã€‚

