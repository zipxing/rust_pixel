// RustPixel
// copyright zipxing@hotmail.com 2022～2025

//! **RustPixel** is a lightweight, glyph-based 2D game engine and rapid-prototyping toolkit.
//!
//! It provides a unified abstraction for both **terminal** and **graphic** rendering modes
//! (including WebAssembly), allowing developers to build pixel-style games, tools, and
//! simulation prototypes with minimal boilerplate.
//!
//! RustPixel supports **TUI both with and without a real terminal environment**, thanks to its
//! built-in glyph atlas and software-rendered text engine. This enables rich UI overlays on
//! top of game layers even in pure graphic mode.
//!
//! Designed for clarity, portability, and fast iteration, RustPixel is ideal for:
//! - Glyph / PETSCII / ASCII / emoji-based pixel games
//! - Terminal applications & hybrid TUI-over-graphics UIs
//! - Rapid prototyping of gameplay ideas
//! - Cross-platform rendering (Desktop, Web, Mobile, Mini-Game platforms)
//!
//! RustPixel's architecture emphasizes simplicity and composability, making it a practical
//! foundation for building both experimental and production-ready pixel-driven experiences.
//!
//! Rendering modes:
//! - Text mode: Runs in a terminal via `crossterm`, drawing with ASCII and Unicode/Emoji.
//! - Graphics mode (native): Uses `wgpu` or `SDL2`, rendering PETSCII and custom symbol sets.
//! - Graphics mode (web): Same core logic compiled to WASM, rendered via WebGL + JavaScript
//!   (see `rust-pixel/web-template/pixel.js`).
//!
//! Core concepts:
//! - Cell: Smallest renderable unit (a character in text mode, or a fixed‑size glyph in graphics mode).
//! - Buffer: A collection of cells representing the screen state, with diff‑friendly updates.
//! - Panel/Sprite/Style: Higher‑level drawing abstractions that work uniformly across backends.
//!
//! Modules overview:
//! - `algorithm`, `event`, `util`: Always available; form the minimal runtime.
//! - `asset`, `audio`, `context`, `game`, `log`, `render`, `ui`: Enabled when not in `base` mode.
//!
//! Minimal build (base mode): Only `algorithm`, `event`, and `util` are compiled, reducing
//! dependencies for shipping as FFI or WASM libraries. This is ideal when you only need the
//! engine’s core data structures and event system.

use std::sync::OnceLock;

/// Global game configuration - initialized once at startup
/// 
/// This provides a single source of truth for game name and project path,
/// accessible from anywhere in the codebase without passing references.
#[derive(Debug, Clone)]
pub struct GameConfig {
    /// Game name identifier
    pub game_name: String,
    /// Project root path for asset loading
    pub project_path: String,
}

/// Global static game configuration
pub static GAME_CONFIG: OnceLock<GameConfig> = OnceLock::new();

/// Initialize the global game configuration
/// This should be called once at program startup before any other initialization.
pub fn init_game_config(game_name: &str, project_path: &str) {
    let _ = GAME_CONFIG.set(GameConfig {
        game_name: game_name.to_string(),
        project_path: project_path.to_string(),
    });
}

/// Get a reference to the global game configuration
/// If not initialized, returns a default config with empty game_name and "." as project_path.
/// This allows for gradual migration and testing scenarios.
pub fn get_game_config() -> &'static GameConfig {
    GAME_CONFIG.get_or_init(|| {
        // Default configuration for testing and backward compatibility
        GameConfig {
            game_name: String::new(),
            project_path: ".".to_string(),
        }
    })
}

/// Target frames per second for the main game loop. Keep this moderate to conserve CPU.
pub const GAME_FRAME: u32 = 60;

#[cfg(not(graphics_mode))]
pub const LOGO_FRAME: u32 = GAME_FRAME / 4 * 2;

#[cfg(graphics_mode)]
pub const LOGO_FRAME: u32 = GAME_FRAME / 4 * 5;

/// Re‑export the `paste` crate so downstream crates can use it in macros generated by this crate.
#[cfg(not(feature = "base"))]
pub use paste;

/// Macro `pixel_game` to scaffold a RustPixel application entry.
///
/// ## Architecture
///
/// This macro implements the conventional `lib.rs` + `main.rs` split used by RustPixel apps.
/// Although the split may look redundant, it is crucial for cross‑platform deployment and a
/// consistent framework architecture.
///
/// ### Why split `lib.rs` and `main.rs`?
///
/// - WASM builds require `crate-type = ["cdylib", "rlib"]` and do not use `main()`; instead,
///   exported functions are called from JavaScript. The generated `{Name}Game` methods such as
///   `new()`, `tick()`, and `key_event()` can be exported for the Web frontend.
/// - Multi‑platform deployment:
///   - Native binary: `main.rs` calls `{crate_name}::run()` from `lib.rs`.
///   - WASM library: JavaScript calls `{Name}Game::new()`, `tick()`, etc., from `lib.rs`.
///   - Library dependency: Other crates can depend on the library API in `lib.rs`.
/// - Unified architecture: All RustPixel games follow the same Model + Render + Game pattern,
///   enabling consistent interfaces across terminal, SDL2, and Web backends.
/// - Code organization: `lib.rs` defines the public API and integration points; `main.rs`
///   provides the native entry point. This improves testability and conditional compilation.
///
/// ### What does the macro generate?
///
/// ```rust
/// // Module structure
/// mod model;           // Game logic and state
/// mod render_terminal; // Terminal-mode rendering (text-based)
/// mod render_graphics; // Graphics-mode rendering (SDL/Web)
///
/// // Generated structs and functions
/// pub struct {Name}Game {
///     g: Game<{Name}Model, {Name}Render>,
/// }
///
/// pub fn init_game() -> {Name}Game { /* ... */ }
/// pub fn run() { /* ... */ } // Called by main.rs
///
/// // WASM-specific exports
/// impl {Name}Game {
///     pub fn new() -> Self { /* ... */ }          // WASM constructor
///     pub fn tick(&mut self, dt: f32) { /* ... */ } // WASM game loop
///     pub fn key_event(&mut self, /* ... */) { /* ... */ } // WASM input
/// }
/// ```
///
/// With this single macro, your game can run as:
/// - Terminal app (crossterm backend)
/// - Desktop app (opengl or wgpu backend)
/// - Web app (WebGL via WASM)
/// - A library embedded in other Rust projects
#[cfg(not(feature = "base"))]
#[macro_export]
macro_rules! pixel_game {
    ($name:ident) => {
        mod model;
        #[cfg(not(graphics_mode))]
        mod render_terminal;
        #[cfg(graphics_mode)]
        mod render_graphics;

        #[cfg(not(graphics_mode))]
        use crate::{model::*, render_terminal::*};
        #[cfg(graphics_mode)]
        use crate::{model::*, render_graphics::*};
        use rust_pixel::game::Game;
        use rust_pixel::util::get_project_path;

        #[cfg(wasm)]
        use rust_pixel::render::adapter::web_adapter::{input_events_from_web, WebAdapter};
        use wasm_bindgen::prelude::*;
        #[cfg(wasm)]
        use wasm_bindgen_futures::js_sys;
        #[cfg(wasm)]
        use log::info;

        rust_pixel::paste::paste! {
            #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
            pub struct [<$name Game>] {
                g: Game<[<$name Model>], [<$name Render>]>,
            }

            pub fn init_game() -> [<$name Game>] {
                let m = [<$name Model>]::new();
                let r = [<$name Render>]::new();
                let pp = get_project_path();
                println!("asset path : {:?}", pp);
                // Initialize global game config (ignore if already initialized)
                rust_pixel::init_game_config(stringify!([<$name:lower>]), &pp);
                let mut g = Game::new(m, r);
                g.init();
                [<$name Game>] { g }
            }

            #[cfg(wasm)]
            #[cfg_attr(target_arch = "wasm32", wasm_bindgen)]
            impl [<$name Game>] {
                pub fn new() -> Self {
                    init_game()
                }

                pub fn tick(&mut self, dt: f32) {
                    self.g.on_tick(dt);
                }

                pub fn key_event(&mut self, t: u8, e: web_sys::Event) {
                    let abase = &self
                        .g
                        .context
                        .adapter
                        .as_any()
                        .downcast_ref::<WebAdapter>()
                        .unwrap()
                        .base;
                    if let Some(pe) = input_events_from_web(t, e, abase.gr.pixel_h, abase.gr.ratio_x, abase.gr.ratio_y, abase.gr.use_tui_height) {
                        self.g.context.input_events.push(pe);
                    }
                }

                pub fn upload_imgdata(&mut self, w: i32, h: i32, d: &js_sys::Uint8ClampedArray) {
                    let length = d.length() as usize;
                    let mut pixels = vec![0u8; length];
                    d.copy_to(&mut pixels);
                    info!("RUST...pixels.len={}", pixels.len());

                    let wa = &mut self
                        .g
                        .context
                        .adapter
                        .as_any()
                        .downcast_mut::<WebAdapter>()
                        .unwrap();

                    wa.init_glpix(w, h, &pixels);
                }

                pub fn on_asset_loaded(&mut self, url: &str, data: &[u8]) {
                    self.g.context.asset_manager.set_data(url, data);
                }

                pub fn get_ratiox(&mut self) -> f32 {
                    self.g.context.adapter.get_base().gr.ratio_x
                }

                pub fn get_ratioy(&mut self) -> f32 {
                    self.g.context.adapter.get_base().gr.ratio_y
                }
            }

            pub fn run() {
                let mut g = init_game().g;
                g.run().unwrap();
                g.render.panel.reset(&mut g.context);
            }
        }
    };
}

/// Algorithms and data structures used by demos and utilities (e.g., disjoint‑set/union‑find,
/// A* pathfinding).
pub mod algorithm;

/// Resource/asset manager with optional asynchronous loading for better compatibility with WASM.
#[cfg(not(feature = "base"))]
pub mod asset;

/// Event system for input, timers, and custom user events.
pub mod event;

/// Alternative event implementation used for benchmarking and mutex‑based comparisons.
pub mod event_mutex;

/// Common utilities and data structures such as object pools, RNG, matrices, circles, and dots.
pub mod util;

/// Audio playback utilities and abstractions.
#[cfg(not(feature = "base"))]
pub mod audio;

/// Runtime context, including the active rendering adapter and other shared state.
#[cfg(not(feature = "base"))]
pub mod context;

/// Game orchestration: integrates model and renderer, encapsulating the main loop.
#[cfg(not(feature = "base"))]
pub mod game;

/// Logging facilities tailored for demos and examples.
pub mod log;

/// Rendering subsystem supporting both text and graphics modes.
///
/// Components:
/// - Adapter: Rendering adapter interface (crossterm; winit + glow/wgpu; SDL + glow; Web).
/// - Cell: Base drawing unit (character in text mode; glyph/small bitmap in graphics mode).
/// - Buffer: Screen buffer built from cells, with efficient updates.
/// - Sprite: Higher‑level drawing primitive built on top of buffers.
/// - Style: Foreground/background colors and other attributes.
/// - Panel: Unified drawing surface that works in both modes.
///
/// In text mode a cell is a Unicode character. In graphics mode a cell can be a fixed‑size dot
/// matrix image, a PETSCII character, or a custom texture. Graphics mode also supports per‑sprite
/// pixel offsets to improve expressiveness.
#[cfg(not(feature = "base"))]
pub mod render;

/// UI framework for building character‑based interfaces, including widgets, layouts, events,
/// and themes for rapid development.
#[cfg(not(feature = "base"))]
pub mod ui;

