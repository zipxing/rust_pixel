# Block Arrow

方块箭头谜题游戏。关卡由像素画自动生成，玩家点击方块沿箭头方向飞走，全部清除即通关。

## 玩法

- 给定一张小分辨率像素画（最大 16×16），用 polyomino 方块覆盖所有彩色像素
- 每个方块标注一个方向箭头（▲▼◀▶）
- 鼠标点击方块：箭头方向无遮挡则飞走，有遮挡则闪烁提示
- 全部方块飞走即通关，展示原始像素画

## 操作

| 操作 | 说明 |
|------|------|
| 鼠标左键点击方块 | 飞走（可飞时）/ 闪烁（被挡时） |
| R | 重新开始当前关卡 |
| N | 下一关（通关后） |
| Q / Esc | 退出 |

## 方块形状库

| 类别 | 名称 | 面积 | 变体数 |
|------|------|------|--------|
| monomino | O1 | 1 | 1 |
| domino | I2 | 2 | 2 |
| triomino | I3, L3 | 3 | 2, 4 |
| tetromino | I4, O4, T, S, Z, J, L | 4 | 2,1,4,2,2,4,4 |
| pentomino | P5, F5, U5, N5 | 5 | 4,4,4,4 |

旋转生成（无镜像），去重后得到变体集。

## 关卡生成算法

1. **覆盖**：按颜色分区，回溯搜索用方块无重叠覆盖所有同色像素（优先大块）
2. **箭头分配**：贪心法——每轮找一个能沿某方向无障碍飞走的方块，赋箭头并移除，重复至清空
3. **重试**：若某次覆盖方案无法分配可解箭头，重新覆盖，最多 100 次
4. 返回的关卡 **保证有解**，`Level.solution` 即为解序列

## 难度评估

`evaluate_difficulty(level)` 返回 `LevelDifficulty`，包含多维度指标和加权总分（0～100）：

| 维度 | 权重 | 计算方式 | 说明 |
|------|------|----------|------|
| 最长依赖链 | 40% | `max_chain / (block_count - 1)` | 必须严格按顺序消除的最长路径，核心难度因子 |
| 初始卡住比例 | 25% | `1 - initial_free_ratio` | 开局无法直接飞走的方块占比 |
| 方块数量 | 15% | `block_count / 30`（上限 1.0） | 方块越多，选择越多，越容易犯错 |
| 棋盘密度 | 10% | `filled_pixels / total_pixels` | 像素越满，相互遮挡越严重 |
| 颜色种类 | 10% | `color_count / 8`（上限 1.0） | 颜色多视觉干扰更大 |

**公式**：`score = chain×40 + stuck×25 + blocks×15 + density×10 + colors×10`

**依赖链计算**：对每个方块构建 DAG（谁挡住谁），通过记忆化 DFS 求最长路径。

示例输出：

```
Level 0: blocks=24, colors=3, density=0.85, chain=4, free=0.38, score=46.9
Level 1: blocks=27, colors=6, density=0.98, chain=4, free=0.37, score=52.6
```

## 颜色定义

位图像素值 1～8 对应颜色：

| 值 | 颜色 |
|----|------|
| 1 | 蓝 |
| 2 | 绿 |
| 3 | 红 |
| 4 | 木头褐 |
| 5 | 黄 |
| 6 | 深灰 |
| 7 | 亮红 |
| 8 | 白 |

## 文件结构

```
apps/block_arrow/
├── lib/src/lib.rs          # 核心算法：形状库、覆盖、箭头分配、难度评估
├── src/
│   ├── model.rs            # 游戏状态：Board、鼠标输入、飞行动画、闪烁
│   ├── render_terminal.rs  # 终端渲染：边框填色、飞出动画、showcase
│   └── render_graphics.rs  # 图形模式（待实现）
└── assets/
    └── cc0.txt ~ cc15.txt  # 边框资源（4bit邻接编码）
```

## 运行

```bash
cargo pixel r block_arrow t    # 终端模式
```
